// Automatically generated by xdrgen
// DO NOT EDIT or your changes may be overwritten

package org.stellar.sdk.xdr;

import static org.stellar.sdk.xdr.Constants.*;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.Objects;
import org.stellar.sdk.Base64Factory;

// === xdr source ============================================================

//  struct StateArchivalSettings {
//      uint32 maxEntryTTL;
//      uint32 minTemporaryTTL;
//      uint32 minPersistentTTL;
//
//      // rent_fee = wfee_rate_average / rent_rate_denominator_for_type
//      int64 persistentRentRateDenominator;
//      int64 tempRentRateDenominator;
//
//      // max number of entries that emit archival meta in a single ledger
//      uint32 maxEntriesToArchive;
//
//      // Number of snapshots to use when calculating average BucketList size
//      uint32 bucketListSizeWindowSampleSize;
//
//      // Maximum number of bytes that we scan for eviction per ledger
//      uint64 evictionScanSize;
//
//      // Lowest BucketList level to be scanned to evict entries
//      uint32 startingEvictionScanLevel;
//  };

//  ===========================================================================
public class StateArchivalSettings implements XdrElement {
  public StateArchivalSettings() {}

  private Uint32 maxEntryTTL;

  public Uint32 getMaxEntryTTL() {
    return this.maxEntryTTL;
  }

  public void setMaxEntryTTL(Uint32 value) {
    this.maxEntryTTL = value;
  }

  private Uint32 minTemporaryTTL;

  public Uint32 getMinTemporaryTTL() {
    return this.minTemporaryTTL;
  }

  public void setMinTemporaryTTL(Uint32 value) {
    this.minTemporaryTTL = value;
  }

  private Uint32 minPersistentTTL;

  public Uint32 getMinPersistentTTL() {
    return this.minPersistentTTL;
  }

  public void setMinPersistentTTL(Uint32 value) {
    this.minPersistentTTL = value;
  }

  private Int64 persistentRentRateDenominator;

  public Int64 getPersistentRentRateDenominator() {
    return this.persistentRentRateDenominator;
  }

  public void setPersistentRentRateDenominator(Int64 value) {
    this.persistentRentRateDenominator = value;
  }

  private Int64 tempRentRateDenominator;

  public Int64 getTempRentRateDenominator() {
    return this.tempRentRateDenominator;
  }

  public void setTempRentRateDenominator(Int64 value) {
    this.tempRentRateDenominator = value;
  }

  private Uint32 maxEntriesToArchive;

  public Uint32 getMaxEntriesToArchive() {
    return this.maxEntriesToArchive;
  }

  public void setMaxEntriesToArchive(Uint32 value) {
    this.maxEntriesToArchive = value;
  }

  private Uint32 bucketListSizeWindowSampleSize;

  public Uint32 getBucketListSizeWindowSampleSize() {
    return this.bucketListSizeWindowSampleSize;
  }

  public void setBucketListSizeWindowSampleSize(Uint32 value) {
    this.bucketListSizeWindowSampleSize = value;
  }

  private Uint64 evictionScanSize;

  public Uint64 getEvictionScanSize() {
    return this.evictionScanSize;
  }

  public void setEvictionScanSize(Uint64 value) {
    this.evictionScanSize = value;
  }

  private Uint32 startingEvictionScanLevel;

  public Uint32 getStartingEvictionScanLevel() {
    return this.startingEvictionScanLevel;
  }

  public void setStartingEvictionScanLevel(Uint32 value) {
    this.startingEvictionScanLevel = value;
  }

  public static void encode(
      XdrDataOutputStream stream, StateArchivalSettings encodedStateArchivalSettings)
      throws IOException {
    Uint32.encode(stream, encodedStateArchivalSettings.maxEntryTTL);
    Uint32.encode(stream, encodedStateArchivalSettings.minTemporaryTTL);
    Uint32.encode(stream, encodedStateArchivalSettings.minPersistentTTL);
    Int64.encode(stream, encodedStateArchivalSettings.persistentRentRateDenominator);
    Int64.encode(stream, encodedStateArchivalSettings.tempRentRateDenominator);
    Uint32.encode(stream, encodedStateArchivalSettings.maxEntriesToArchive);
    Uint32.encode(stream, encodedStateArchivalSettings.bucketListSizeWindowSampleSize);
    Uint64.encode(stream, encodedStateArchivalSettings.evictionScanSize);
    Uint32.encode(stream, encodedStateArchivalSettings.startingEvictionScanLevel);
  }

  public void encode(XdrDataOutputStream stream) throws IOException {
    encode(stream, this);
  }

  public static StateArchivalSettings decode(XdrDataInputStream stream) throws IOException {
    StateArchivalSettings decodedStateArchivalSettings = new StateArchivalSettings();
    decodedStateArchivalSettings.maxEntryTTL = Uint32.decode(stream);
    decodedStateArchivalSettings.minTemporaryTTL = Uint32.decode(stream);
    decodedStateArchivalSettings.minPersistentTTL = Uint32.decode(stream);
    decodedStateArchivalSettings.persistentRentRateDenominator = Int64.decode(stream);
    decodedStateArchivalSettings.tempRentRateDenominator = Int64.decode(stream);
    decodedStateArchivalSettings.maxEntriesToArchive = Uint32.decode(stream);
    decodedStateArchivalSettings.bucketListSizeWindowSampleSize = Uint32.decode(stream);
    decodedStateArchivalSettings.evictionScanSize = Uint64.decode(stream);
    decodedStateArchivalSettings.startingEvictionScanLevel = Uint32.decode(stream);
    return decodedStateArchivalSettings;
  }

  @Override
  public int hashCode() {
    return Objects.hash(
        this.maxEntryTTL,
        this.minTemporaryTTL,
        this.minPersistentTTL,
        this.persistentRentRateDenominator,
        this.tempRentRateDenominator,
        this.maxEntriesToArchive,
        this.bucketListSizeWindowSampleSize,
        this.evictionScanSize,
        this.startingEvictionScanLevel);
  }

  @Override
  public boolean equals(Object object) {
    if (!(object instanceof StateArchivalSettings)) {
      return false;
    }

    StateArchivalSettings other = (StateArchivalSettings) object;
    return Objects.equals(this.maxEntryTTL, other.maxEntryTTL)
        && Objects.equals(this.minTemporaryTTL, other.minTemporaryTTL)
        && Objects.equals(this.minPersistentTTL, other.minPersistentTTL)
        && Objects.equals(this.persistentRentRateDenominator, other.persistentRentRateDenominator)
        && Objects.equals(this.tempRentRateDenominator, other.tempRentRateDenominator)
        && Objects.equals(this.maxEntriesToArchive, other.maxEntriesToArchive)
        && Objects.equals(this.bucketListSizeWindowSampleSize, other.bucketListSizeWindowSampleSize)
        && Objects.equals(this.evictionScanSize, other.evictionScanSize)
        && Objects.equals(this.startingEvictionScanLevel, other.startingEvictionScanLevel);
  }

  @Override
  public String toXdrBase64() throws IOException {
    return Base64Factory.getInstance().encodeToString(toXdrByteArray());
  }

  @Override
  public byte[] toXdrByteArray() throws IOException {
    ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
    XdrDataOutputStream xdrDataOutputStream = new XdrDataOutputStream(byteArrayOutputStream);
    encode(xdrDataOutputStream);
    return byteArrayOutputStream.toByteArray();
  }

  public static StateArchivalSettings fromXdrBase64(String xdr) throws IOException {
    byte[] bytes = Base64Factory.getInstance().decode(xdr);
    return fromXdrByteArray(bytes);
  }

  public static StateArchivalSettings fromXdrByteArray(byte[] xdr) throws IOException {
    ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(xdr);
    XdrDataInputStream xdrDataInputStream = new XdrDataInputStream(byteArrayInputStream);
    return decode(xdrDataInputStream);
  }

  public static final class Builder {
    private Uint32 maxEntryTTL;
    private Uint32 minTemporaryTTL;
    private Uint32 minPersistentTTL;
    private Int64 persistentRentRateDenominator;
    private Int64 tempRentRateDenominator;
    private Uint32 maxEntriesToArchive;
    private Uint32 bucketListSizeWindowSampleSize;
    private Uint64 evictionScanSize;
    private Uint32 startingEvictionScanLevel;

    public Builder maxEntryTTL(Uint32 maxEntryTTL) {
      this.maxEntryTTL = maxEntryTTL;
      return this;
    }

    public Builder minTemporaryTTL(Uint32 minTemporaryTTL) {
      this.minTemporaryTTL = minTemporaryTTL;
      return this;
    }

    public Builder minPersistentTTL(Uint32 minPersistentTTL) {
      this.minPersistentTTL = minPersistentTTL;
      return this;
    }

    public Builder persistentRentRateDenominator(Int64 persistentRentRateDenominator) {
      this.persistentRentRateDenominator = persistentRentRateDenominator;
      return this;
    }

    public Builder tempRentRateDenominator(Int64 tempRentRateDenominator) {
      this.tempRentRateDenominator = tempRentRateDenominator;
      return this;
    }

    public Builder maxEntriesToArchive(Uint32 maxEntriesToArchive) {
      this.maxEntriesToArchive = maxEntriesToArchive;
      return this;
    }

    public Builder bucketListSizeWindowSampleSize(Uint32 bucketListSizeWindowSampleSize) {
      this.bucketListSizeWindowSampleSize = bucketListSizeWindowSampleSize;
      return this;
    }

    public Builder evictionScanSize(Uint64 evictionScanSize) {
      this.evictionScanSize = evictionScanSize;
      return this;
    }

    public Builder startingEvictionScanLevel(Uint32 startingEvictionScanLevel) {
      this.startingEvictionScanLevel = startingEvictionScanLevel;
      return this;
    }

    public StateArchivalSettings build() {
      StateArchivalSettings val = new StateArchivalSettings();
      val.setMaxEntryTTL(this.maxEntryTTL);
      val.setMinTemporaryTTL(this.minTemporaryTTL);
      val.setMinPersistentTTL(this.minPersistentTTL);
      val.setPersistentRentRateDenominator(this.persistentRentRateDenominator);
      val.setTempRentRateDenominator(this.tempRentRateDenominator);
      val.setMaxEntriesToArchive(this.maxEntriesToArchive);
      val.setBucketListSizeWindowSampleSize(this.bucketListSizeWindowSampleSize);
      val.setEvictionScanSize(this.evictionScanSize);
      val.setStartingEvictionScanLevel(this.startingEvictionScanLevel);
      return val;
    }
  }
}
