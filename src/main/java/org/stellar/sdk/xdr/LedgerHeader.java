// Automatically generated by xdrgen
// DO NOT EDIT or your changes may be overwritten

package org.stellar.sdk.xdr;

import static org.stellar.sdk.xdr.Constants.*;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.stellar.sdk.Base64Factory;

/**
 * LedgerHeader's original definition in the XDR file is:
 *
 * <pre>
 * struct LedgerHeader
 * {
 *     uint32 ledgerVersion;    // the protocol version of the ledger
 *     Hash previousLedgerHash; // hash of the previous ledger header
 *     StellarValue scpValue;   // what consensus agreed to
 *     Hash txSetResultHash;    // the TransactionResultSet that led to this ledger
 *     Hash bucketListHash;     // hash of the ledger state
 *
 *     uint32 ledgerSeq; // sequence number of this ledger
 *
 *     int64 totalCoins; // total number of stroops in existence.
 *                       // 10,000,000 stroops in 1 XLM
 *
 *     int64 feePool;       // fees burned since last inflation run
 *     uint32 inflationSeq; // inflation sequence number
 *
 *     uint64 idPool; // last used global ID, used for generating objects
 *
 *     uint32 baseFee;     // base fee per operation in stroops
 *     uint32 baseReserve; // account base reserve in stroops
 *
 *     uint32 maxTxSetSize; // maximum size a transaction set can be
 *
 *     Hash skipList[4]; // hashes of ledgers in the past. allows you to jump back
 *                       // in time without walking the chain back ledger by ledger
 *                       // each slot contains the oldest ledger that is mod of
 *                       // either 50  5000  50000 or 500000 depending on index
 *                       // skipList[0] mod(50), skipList[1] mod(5000), etc
 *
 *     // reserved for future use
 *     union switch (int v)
 *     {
 *     case 0:
 *         void;
 *     case 1:
 *         LedgerHeaderExtensionV1 v1;
 *     }
 *     ext;
 * };
 * </pre>
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder(toBuilder = true)
public class LedgerHeader implements XdrElement {
  private Uint32 ledgerVersion;
  private Hash previousLedgerHash;
  private StellarValue scpValue;
  private Hash txSetResultHash;
  private Hash bucketListHash;
  private Uint32 ledgerSeq;
  private Int64 totalCoins;
  private Int64 feePool;
  private Uint32 inflationSeq;
  private Uint64 idPool;
  private Uint32 baseFee;
  private Uint32 baseReserve;
  private Uint32 maxTxSetSize;
  private Hash[] skipList;
  private LedgerHeaderExt ext;

  public static void encode(XdrDataOutputStream stream, LedgerHeader encodedLedgerHeader)
      throws IOException {
    Uint32.encode(stream, encodedLedgerHeader.ledgerVersion);
    Hash.encode(stream, encodedLedgerHeader.previousLedgerHash);
    StellarValue.encode(stream, encodedLedgerHeader.scpValue);
    Hash.encode(stream, encodedLedgerHeader.txSetResultHash);
    Hash.encode(stream, encodedLedgerHeader.bucketListHash);
    Uint32.encode(stream, encodedLedgerHeader.ledgerSeq);
    Int64.encode(stream, encodedLedgerHeader.totalCoins);
    Int64.encode(stream, encodedLedgerHeader.feePool);
    Uint32.encode(stream, encodedLedgerHeader.inflationSeq);
    Uint64.encode(stream, encodedLedgerHeader.idPool);
    Uint32.encode(stream, encodedLedgerHeader.baseFee);
    Uint32.encode(stream, encodedLedgerHeader.baseReserve);
    Uint32.encode(stream, encodedLedgerHeader.maxTxSetSize);
    int skipListSize = encodedLedgerHeader.getSkipList().length;
    for (int i = 0; i < skipListSize; i++) {
      Hash.encode(stream, encodedLedgerHeader.skipList[i]);
    }
    LedgerHeaderExt.encode(stream, encodedLedgerHeader.ext);
  }

  public void encode(XdrDataOutputStream stream) throws IOException {
    encode(stream, this);
  }

  public static LedgerHeader decode(XdrDataInputStream stream) throws IOException {
    LedgerHeader decodedLedgerHeader = new LedgerHeader();
    decodedLedgerHeader.ledgerVersion = Uint32.decode(stream);
    decodedLedgerHeader.previousLedgerHash = Hash.decode(stream);
    decodedLedgerHeader.scpValue = StellarValue.decode(stream);
    decodedLedgerHeader.txSetResultHash = Hash.decode(stream);
    decodedLedgerHeader.bucketListHash = Hash.decode(stream);
    decodedLedgerHeader.ledgerSeq = Uint32.decode(stream);
    decodedLedgerHeader.totalCoins = Int64.decode(stream);
    decodedLedgerHeader.feePool = Int64.decode(stream);
    decodedLedgerHeader.inflationSeq = Uint32.decode(stream);
    decodedLedgerHeader.idPool = Uint64.decode(stream);
    decodedLedgerHeader.baseFee = Uint32.decode(stream);
    decodedLedgerHeader.baseReserve = Uint32.decode(stream);
    decodedLedgerHeader.maxTxSetSize = Uint32.decode(stream);
    int skipListSize = 4;
    decodedLedgerHeader.skipList = new Hash[skipListSize];
    for (int i = 0; i < skipListSize; i++) {
      decodedLedgerHeader.skipList[i] = Hash.decode(stream);
    }
    decodedLedgerHeader.ext = LedgerHeaderExt.decode(stream);
    return decodedLedgerHeader;
  }

  @Override
  public String toXdrBase64() throws IOException {
    return Base64Factory.getInstance().encodeToString(toXdrByteArray());
  }

  @Override
  public byte[] toXdrByteArray() throws IOException {
    ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
    XdrDataOutputStream xdrDataOutputStream = new XdrDataOutputStream(byteArrayOutputStream);
    encode(xdrDataOutputStream);
    return byteArrayOutputStream.toByteArray();
  }

  public static LedgerHeader fromXdrBase64(String xdr) throws IOException {
    byte[] bytes = Base64Factory.getInstance().decode(xdr);
    return fromXdrByteArray(bytes);
  }

  public static LedgerHeader fromXdrByteArray(byte[] xdr) throws IOException {
    ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(xdr);
    XdrDataInputStream xdrDataInputStream = new XdrDataInputStream(byteArrayInputStream);
    return decode(xdrDataInputStream);
  }

  /**
   * LedgerHeaderExt's original definition in the XDR file is:
   *
   * <pre>
   * union switch (int v)
   *     {
   *     case 0:
   *         void;
   *     case 1:
   *         LedgerHeaderExtensionV1 v1;
   *     }
   * </pre>
   */
  @Data
  @NoArgsConstructor
  @AllArgsConstructor
  @Builder(toBuilder = true)
  public static class LedgerHeaderExt implements XdrElement {
    private Integer discriminant;
    private LedgerHeaderExtensionV1 v1;

    public static void encode(XdrDataOutputStream stream, LedgerHeaderExt encodedLedgerHeaderExt)
        throws IOException {
      // Xdrgen::AST::Typespecs::Int
      // Integer
      stream.writeInt(encodedLedgerHeaderExt.getDiscriminant().intValue());
      switch (encodedLedgerHeaderExt.getDiscriminant()) {
        case 0:
          break;
        case 1:
          LedgerHeaderExtensionV1.encode(stream, encodedLedgerHeaderExt.v1);
          break;
      }
    }

    public void encode(XdrDataOutputStream stream) throws IOException {
      encode(stream, this);
    }

    public static LedgerHeaderExt decode(XdrDataInputStream stream) throws IOException {
      LedgerHeaderExt decodedLedgerHeaderExt = new LedgerHeaderExt();
      Integer discriminant = stream.readInt();
      decodedLedgerHeaderExt.setDiscriminant(discriminant);
      switch (decodedLedgerHeaderExt.getDiscriminant()) {
        case 0:
          break;
        case 1:
          decodedLedgerHeaderExt.v1 = LedgerHeaderExtensionV1.decode(stream);
          break;
      }
      return decodedLedgerHeaderExt;
    }

    @Override
    public String toXdrBase64() throws IOException {
      return Base64Factory.getInstance().encodeToString(toXdrByteArray());
    }

    @Override
    public byte[] toXdrByteArray() throws IOException {
      ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
      XdrDataOutputStream xdrDataOutputStream = new XdrDataOutputStream(byteArrayOutputStream);
      encode(xdrDataOutputStream);
      return byteArrayOutputStream.toByteArray();
    }

    public static LedgerHeaderExt fromXdrBase64(String xdr) throws IOException {
      byte[] bytes = Base64Factory.getInstance().decode(xdr);
      return fromXdrByteArray(bytes);
    }

    public static LedgerHeaderExt fromXdrByteArray(byte[] xdr) throws IOException {
      ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(xdr);
      XdrDataInputStream xdrDataInputStream = new XdrDataInputStream(byteArrayInputStream);
      return decode(xdrDataInputStream);
    }
  }
}
