// Automatically generated by xdrgen
// DO NOT EDIT or your changes may be overwritten

package org.stellar.sdk.xdr;

import com.google.common.base.Objects;
import java.io.IOException;

// === xdr source ============================================================

//  union LedgerUpgrade switch (LedgerUpgradeType type)
//  {
//  case LEDGER_UPGRADE_VERSION:
//      uint32 newLedgerVersion; // update ledgerVersion
//  case LEDGER_UPGRADE_BASE_FEE:
//      uint32 newBaseFee; // update baseFee
//  case LEDGER_UPGRADE_MAX_TX_SET_SIZE:
//      uint32 newMaxTxSetSize; // update maxTxSetSize
//  case LEDGER_UPGRADE_BASE_RESERVE:
//      uint32 newBaseReserve; // update baseReserve
//  case LEDGER_UPGRADE_FLAGS:
//      uint32 newFlags; // update flags
//  };

//  ===========================================================================
public class LedgerUpgrade implements XdrElement {
  public LedgerUpgrade() {}

  LedgerUpgradeType type;

  public LedgerUpgradeType getDiscriminant() {
    return this.type;
  }

  public void setDiscriminant(LedgerUpgradeType value) {
    this.type = value;
  }

  private Uint32 newLedgerVersion;

  public Uint32 getNewLedgerVersion() {
    return this.newLedgerVersion;
  }

  public void setNewLedgerVersion(Uint32 value) {
    this.newLedgerVersion = value;
  }

  private Uint32 newBaseFee;

  public Uint32 getNewBaseFee() {
    return this.newBaseFee;
  }

  public void setNewBaseFee(Uint32 value) {
    this.newBaseFee = value;
  }

  private Uint32 newMaxTxSetSize;

  public Uint32 getNewMaxTxSetSize() {
    return this.newMaxTxSetSize;
  }

  public void setNewMaxTxSetSize(Uint32 value) {
    this.newMaxTxSetSize = value;
  }

  private Uint32 newBaseReserve;

  public Uint32 getNewBaseReserve() {
    return this.newBaseReserve;
  }

  public void setNewBaseReserve(Uint32 value) {
    this.newBaseReserve = value;
  }

  private Uint32 newFlags;

  public Uint32 getNewFlags() {
    return this.newFlags;
  }

  public void setNewFlags(Uint32 value) {
    this.newFlags = value;
  }

  public static final class Builder {
    private LedgerUpgradeType discriminant;
    private Uint32 newLedgerVersion;
    private Uint32 newBaseFee;
    private Uint32 newMaxTxSetSize;
    private Uint32 newBaseReserve;
    private Uint32 newFlags;

    public Builder discriminant(LedgerUpgradeType discriminant) {
      this.discriminant = discriminant;
      return this;
    }

    public Builder newLedgerVersion(Uint32 newLedgerVersion) {
      this.newLedgerVersion = newLedgerVersion;
      return this;
    }

    public Builder newBaseFee(Uint32 newBaseFee) {
      this.newBaseFee = newBaseFee;
      return this;
    }

    public Builder newMaxTxSetSize(Uint32 newMaxTxSetSize) {
      this.newMaxTxSetSize = newMaxTxSetSize;
      return this;
    }

    public Builder newBaseReserve(Uint32 newBaseReserve) {
      this.newBaseReserve = newBaseReserve;
      return this;
    }

    public Builder newFlags(Uint32 newFlags) {
      this.newFlags = newFlags;
      return this;
    }

    public LedgerUpgrade build() {
      LedgerUpgrade val = new LedgerUpgrade();
      val.setDiscriminant(discriminant);
      val.setNewLedgerVersion(newLedgerVersion);
      val.setNewBaseFee(newBaseFee);
      val.setNewMaxTxSetSize(newMaxTxSetSize);
      val.setNewBaseReserve(newBaseReserve);
      val.setNewFlags(newFlags);
      return val;
    }
  }

  public static void encode(XdrDataOutputStream stream, LedgerUpgrade encodedLedgerUpgrade)
      throws IOException {
    // Xdrgen::AST::Identifier
    // LedgerUpgradeType
    stream.writeInt(encodedLedgerUpgrade.getDiscriminant().getValue());
    switch (encodedLedgerUpgrade.getDiscriminant()) {
      case LEDGER_UPGRADE_VERSION:
        Uint32.encode(stream, encodedLedgerUpgrade.newLedgerVersion);
        break;
      case LEDGER_UPGRADE_BASE_FEE:
        Uint32.encode(stream, encodedLedgerUpgrade.newBaseFee);
        break;
      case LEDGER_UPGRADE_MAX_TX_SET_SIZE:
        Uint32.encode(stream, encodedLedgerUpgrade.newMaxTxSetSize);
        break;
      case LEDGER_UPGRADE_BASE_RESERVE:
        Uint32.encode(stream, encodedLedgerUpgrade.newBaseReserve);
        break;
      case LEDGER_UPGRADE_FLAGS:
        Uint32.encode(stream, encodedLedgerUpgrade.newFlags);
        break;
    }
  }

  public void encode(XdrDataOutputStream stream) throws IOException {
    encode(stream, this);
  }

  public static LedgerUpgrade decode(XdrDataInputStream stream) throws IOException {
    LedgerUpgrade decodedLedgerUpgrade = new LedgerUpgrade();
    LedgerUpgradeType discriminant = LedgerUpgradeType.decode(stream);
    decodedLedgerUpgrade.setDiscriminant(discriminant);
    switch (decodedLedgerUpgrade.getDiscriminant()) {
      case LEDGER_UPGRADE_VERSION:
        decodedLedgerUpgrade.newLedgerVersion = Uint32.decode(stream);
        break;
      case LEDGER_UPGRADE_BASE_FEE:
        decodedLedgerUpgrade.newBaseFee = Uint32.decode(stream);
        break;
      case LEDGER_UPGRADE_MAX_TX_SET_SIZE:
        decodedLedgerUpgrade.newMaxTxSetSize = Uint32.decode(stream);
        break;
      case LEDGER_UPGRADE_BASE_RESERVE:
        decodedLedgerUpgrade.newBaseReserve = Uint32.decode(stream);
        break;
      case LEDGER_UPGRADE_FLAGS:
        decodedLedgerUpgrade.newFlags = Uint32.decode(stream);
        break;
    }
    return decodedLedgerUpgrade;
  }

  @Override
  public int hashCode() {
    return Objects.hashCode(
        this.newLedgerVersion,
        this.newBaseFee,
        this.newMaxTxSetSize,
        this.newBaseReserve,
        this.newFlags,
        this.type);
  }

  @Override
  public boolean equals(Object object) {
    if (!(object instanceof LedgerUpgrade)) {
      return false;
    }

    LedgerUpgrade other = (LedgerUpgrade) object;
    return Objects.equal(this.newLedgerVersion, other.newLedgerVersion)
        && Objects.equal(this.newBaseFee, other.newBaseFee)
        && Objects.equal(this.newMaxTxSetSize, other.newMaxTxSetSize)
        && Objects.equal(this.newBaseReserve, other.newBaseReserve)
        && Objects.equal(this.newFlags, other.newFlags)
        && Objects.equal(this.type, other.type);
  }
}
