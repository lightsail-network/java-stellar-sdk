// Automatically generated by xdrgen
// DO NOT EDIT or your changes may be overwritten

package org.stellar.sdk.xdr;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.stellar.sdk.Base64Factory;

/**
 * SignerKey's original definition in the XDR file is:
 *
 * <pre>
 * union SignerKey switch (SignerKeyType type)
 * {
 * case SIGNER_KEY_TYPE_ED25519:
 *     uint256 ed25519;
 * case SIGNER_KEY_TYPE_PRE_AUTH_TX:
 *     /&#42; SHA-256 Hash of TransactionSignaturePayload structure &#42;/
 *     uint256 preAuthTx;
 * case SIGNER_KEY_TYPE_HASH_X:
 *     /&#42; Hash of random 256 bit preimage X &#42;/
 *     uint256 hashX;
 * case SIGNER_KEY_TYPE_ED25519_SIGNED_PAYLOAD:
 *     struct
 *     {
 *         /&#42; Public key that must sign the payload. &#42;/
 *         uint256 ed25519;
 *         /&#42; Payload to be raw signed by ed25519. &#42;/
 *         opaque payload&lt;64&gt;;
 *     } ed25519SignedPayload;
 * };
 * </pre>
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder(toBuilder = true)
public class SignerKey implements XdrElement {
  private SignerKeyType discriminant;
  private Uint256 ed25519;
  private Uint256 preAuthTx;
  private Uint256 hashX;
  private SignerKeyEd25519SignedPayload ed25519SignedPayload;

  public void encode(XdrDataOutputStream stream) throws IOException {
    stream.writeInt(discriminant.getValue());
    switch (discriminant) {
      case SIGNER_KEY_TYPE_ED25519:
        ed25519.encode(stream);
        break;
      case SIGNER_KEY_TYPE_PRE_AUTH_TX:
        preAuthTx.encode(stream);
        break;
      case SIGNER_KEY_TYPE_HASH_X:
        hashX.encode(stream);
        break;
      case SIGNER_KEY_TYPE_ED25519_SIGNED_PAYLOAD:
        ed25519SignedPayload.encode(stream);
        break;
    }
  }

  public static SignerKey decode(XdrDataInputStream stream, int maxDepth) throws IOException {
    if (maxDepth <= 0) {
      throw new IOException("Maximum decoding depth reached");
    }
    maxDepth -= 1;
    SignerKey decodedSignerKey = new SignerKey();
    SignerKeyType discriminant = SignerKeyType.decode(stream, maxDepth);
    decodedSignerKey.setDiscriminant(discriminant);
    switch (decodedSignerKey.getDiscriminant()) {
      case SIGNER_KEY_TYPE_ED25519:
        decodedSignerKey.ed25519 = Uint256.decode(stream, maxDepth);
        break;
      case SIGNER_KEY_TYPE_PRE_AUTH_TX:
        decodedSignerKey.preAuthTx = Uint256.decode(stream, maxDepth);
        break;
      case SIGNER_KEY_TYPE_HASH_X:
        decodedSignerKey.hashX = Uint256.decode(stream, maxDepth);
        break;
      case SIGNER_KEY_TYPE_ED25519_SIGNED_PAYLOAD:
        decodedSignerKey.ed25519SignedPayload =
            SignerKeyEd25519SignedPayload.decode(stream, maxDepth);
        break;
      default:
        throw new IOException("Unknown discriminant value: " + discriminant);
    }
    return decodedSignerKey;
  }

  public static SignerKey decode(XdrDataInputStream stream) throws IOException {
    return decode(stream, XdrDataInputStream.DEFAULT_MAX_DEPTH);
  }

  public static SignerKey fromXdrBase64(String xdr) throws IOException {
    byte[] bytes = Base64Factory.getInstance().decode(xdr);
    return fromXdrByteArray(bytes);
  }

  public static SignerKey fromXdrByteArray(byte[] xdr) throws IOException {
    ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(xdr);
    XdrDataInputStream xdrDataInputStream = new XdrDataInputStream(byteArrayInputStream);
    xdrDataInputStream.setMaxInputLen(xdr.length);
    return decode(xdrDataInputStream);
  }

  /**
   * SignerKeyEd25519SignedPayload's original definition in the XDR file is:
   *
   * <pre>
   * struct
   *     {
   *         /&#42; Public key that must sign the payload. &#42;/
   *         uint256 ed25519;
   *         /&#42; Payload to be raw signed by ed25519. &#42;/
   *         opaque payload&lt;64&gt;;
   *     }
   * </pre>
   */
  @Data
  @NoArgsConstructor
  @AllArgsConstructor
  @Builder(toBuilder = true)
  public static class SignerKeyEd25519SignedPayload implements XdrElement {
    private Uint256 ed25519;
    private byte[] payload;

    public void encode(XdrDataOutputStream stream) throws IOException {
      ed25519.encode(stream);
      int payloadSize = payload.length;
      if (payloadSize > 64) {
        throw new IOException("payload size " + payloadSize + " exceeds max size 64");
      }
      stream.writeInt(payloadSize);
      stream.write(getPayload(), 0, payloadSize);
    }

    public static SignerKeyEd25519SignedPayload decode(XdrDataInputStream stream, int maxDepth)
        throws IOException {
      if (maxDepth <= 0) {
        throw new IOException("Maximum decoding depth reached");
      }
      maxDepth -= 1;
      SignerKeyEd25519SignedPayload decodedSignerKeyEd25519SignedPayload =
          new SignerKeyEd25519SignedPayload();
      decodedSignerKeyEd25519SignedPayload.ed25519 = Uint256.decode(stream, maxDepth);
      int payloadSize = stream.readInt();
      if (payloadSize < 0) {
        throw new IOException("payload size " + payloadSize + " is negative");
      }
      if (payloadSize > 64) {
        throw new IOException("payload size " + payloadSize + " exceeds max size 64");
      }
      int payloadRemainingInputLen = stream.getRemainingInputLen();
      if (payloadRemainingInputLen >= 0 && payloadRemainingInputLen < payloadSize) {
        throw new IOException(
            "payload size "
                + payloadSize
                + " exceeds remaining input length "
                + payloadRemainingInputLen);
      }
      decodedSignerKeyEd25519SignedPayload.payload = new byte[payloadSize];
      stream.readPaddedData(decodedSignerKeyEd25519SignedPayload.payload, 0, payloadSize);
      return decodedSignerKeyEd25519SignedPayload;
    }

    public static SignerKeyEd25519SignedPayload decode(XdrDataInputStream stream)
        throws IOException {
      return decode(stream, XdrDataInputStream.DEFAULT_MAX_DEPTH);
    }

    public static SignerKeyEd25519SignedPayload fromXdrBase64(String xdr) throws IOException {
      byte[] bytes = Base64Factory.getInstance().decode(xdr);
      return fromXdrByteArray(bytes);
    }

    public static SignerKeyEd25519SignedPayload fromXdrByteArray(byte[] xdr) throws IOException {
      ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(xdr);
      XdrDataInputStream xdrDataInputStream = new XdrDataInputStream(byteArrayInputStream);
      xdrDataInputStream.setMaxInputLen(xdr.length);
      return decode(xdrDataInputStream);
    }
  }
}
