// Automatically generated by xdrgen
// DO NOT EDIT or your changes may be overwritten

package org.stellar.sdk.xdr;

import static org.stellar.sdk.xdr.Constants.*;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.stellar.sdk.Base64Factory;

/**
 * LedgerEntry's original definition in the XDR file is:
 *
 * <pre>
 * struct LedgerEntry
 * {
 *     uint32 lastModifiedLedgerSeq; // ledger the LedgerEntry was last changed
 *
 *     union switch (LedgerEntryType type)
 *     {
 *     case ACCOUNT:
 *         AccountEntry account;
 *     case TRUSTLINE:
 *         TrustLineEntry trustLine;
 *     case OFFER:
 *         OfferEntry offer;
 *     case DATA:
 *         DataEntry data;
 *     case CLAIMABLE_BALANCE:
 *         ClaimableBalanceEntry claimableBalance;
 *     case LIQUIDITY_POOL:
 *         LiquidityPoolEntry liquidityPool;
 *     case CONTRACT_DATA:
 *         ContractDataEntry contractData;
 *     case CONTRACT_CODE:
 *         ContractCodeEntry contractCode;
 *     case CONFIG_SETTING:
 *         ConfigSettingEntry configSetting;
 *     case TTL:
 *         TTLEntry ttl;
 *     }
 *     data;
 *
 *     // reserved for future use
 *     union switch (int v)
 *     {
 *     case 0:
 *         void;
 *     case 1:
 *         LedgerEntryExtensionV1 v1;
 *     }
 *     ext;
 * };
 * </pre>
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder(toBuilder = true)
public class LedgerEntry implements XdrElement {
  private Uint32 lastModifiedLedgerSeq;
  private LedgerEntryData data;
  private LedgerEntryExt ext;

  public static void encode(XdrDataOutputStream stream, LedgerEntry encodedLedgerEntry)
      throws IOException {
    Uint32.encode(stream, encodedLedgerEntry.lastModifiedLedgerSeq);
    LedgerEntryData.encode(stream, encodedLedgerEntry.data);
    LedgerEntryExt.encode(stream, encodedLedgerEntry.ext);
  }

  public void encode(XdrDataOutputStream stream) throws IOException {
    encode(stream, this);
  }

  public static LedgerEntry decode(XdrDataInputStream stream) throws IOException {
    LedgerEntry decodedLedgerEntry = new LedgerEntry();
    decodedLedgerEntry.lastModifiedLedgerSeq = Uint32.decode(stream);
    decodedLedgerEntry.data = LedgerEntryData.decode(stream);
    decodedLedgerEntry.ext = LedgerEntryExt.decode(stream);
    return decodedLedgerEntry;
  }

  @Override
  public String toXdrBase64() throws IOException {
    return Base64Factory.getInstance().encodeToString(toXdrByteArray());
  }

  @Override
  public byte[] toXdrByteArray() throws IOException {
    ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
    XdrDataOutputStream xdrDataOutputStream = new XdrDataOutputStream(byteArrayOutputStream);
    encode(xdrDataOutputStream);
    return byteArrayOutputStream.toByteArray();
  }

  public static LedgerEntry fromXdrBase64(String xdr) throws IOException {
    byte[] bytes = Base64Factory.getInstance().decode(xdr);
    return fromXdrByteArray(bytes);
  }

  public static LedgerEntry fromXdrByteArray(byte[] xdr) throws IOException {
    ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(xdr);
    XdrDataInputStream xdrDataInputStream = new XdrDataInputStream(byteArrayInputStream);
    return decode(xdrDataInputStream);
  }

  /**
   * LedgerEntryData's original definition in the XDR file is:
   *
   * <pre>
   * union switch (LedgerEntryType type)
   *     {
   *     case ACCOUNT:
   *         AccountEntry account;
   *     case TRUSTLINE:
   *         TrustLineEntry trustLine;
   *     case OFFER:
   *         OfferEntry offer;
   *     case DATA:
   *         DataEntry data;
   *     case CLAIMABLE_BALANCE:
   *         ClaimableBalanceEntry claimableBalance;
   *     case LIQUIDITY_POOL:
   *         LiquidityPoolEntry liquidityPool;
   *     case CONTRACT_DATA:
   *         ContractDataEntry contractData;
   *     case CONTRACT_CODE:
   *         ContractCodeEntry contractCode;
   *     case CONFIG_SETTING:
   *         ConfigSettingEntry configSetting;
   *     case TTL:
   *         TTLEntry ttl;
   *     }
   * </pre>
   */
  @Data
  @NoArgsConstructor
  @AllArgsConstructor
  @Builder(toBuilder = true)
  public static class LedgerEntryData implements XdrElement {
    private LedgerEntryType discriminant;
    private AccountEntry account;
    private TrustLineEntry trustLine;
    private OfferEntry offer;
    private DataEntry data;
    private ClaimableBalanceEntry claimableBalance;
    private LiquidityPoolEntry liquidityPool;
    private ContractDataEntry contractData;
    private ContractCodeEntry contractCode;
    private ConfigSettingEntry configSetting;
    private TTLEntry ttl;

    public static void encode(XdrDataOutputStream stream, LedgerEntryData encodedLedgerEntryData)
        throws IOException {
      // Xdrgen::AST::Identifier
      // LedgerEntryType
      stream.writeInt(encodedLedgerEntryData.getDiscriminant().getValue());
      switch (encodedLedgerEntryData.getDiscriminant()) {
        case ACCOUNT:
          AccountEntry.encode(stream, encodedLedgerEntryData.account);
          break;
        case TRUSTLINE:
          TrustLineEntry.encode(stream, encodedLedgerEntryData.trustLine);
          break;
        case OFFER:
          OfferEntry.encode(stream, encodedLedgerEntryData.offer);
          break;
        case DATA:
          DataEntry.encode(stream, encodedLedgerEntryData.data);
          break;
        case CLAIMABLE_BALANCE:
          ClaimableBalanceEntry.encode(stream, encodedLedgerEntryData.claimableBalance);
          break;
        case LIQUIDITY_POOL:
          LiquidityPoolEntry.encode(stream, encodedLedgerEntryData.liquidityPool);
          break;
        case CONTRACT_DATA:
          ContractDataEntry.encode(stream, encodedLedgerEntryData.contractData);
          break;
        case CONTRACT_CODE:
          ContractCodeEntry.encode(stream, encodedLedgerEntryData.contractCode);
          break;
        case CONFIG_SETTING:
          ConfigSettingEntry.encode(stream, encodedLedgerEntryData.configSetting);
          break;
        case TTL:
          TTLEntry.encode(stream, encodedLedgerEntryData.ttl);
          break;
      }
    }

    public void encode(XdrDataOutputStream stream) throws IOException {
      encode(stream, this);
    }

    public static LedgerEntryData decode(XdrDataInputStream stream) throws IOException {
      LedgerEntryData decodedLedgerEntryData = new LedgerEntryData();
      LedgerEntryType discriminant = LedgerEntryType.decode(stream);
      decodedLedgerEntryData.setDiscriminant(discriminant);
      switch (decodedLedgerEntryData.getDiscriminant()) {
        case ACCOUNT:
          decodedLedgerEntryData.account = AccountEntry.decode(stream);
          break;
        case TRUSTLINE:
          decodedLedgerEntryData.trustLine = TrustLineEntry.decode(stream);
          break;
        case OFFER:
          decodedLedgerEntryData.offer = OfferEntry.decode(stream);
          break;
        case DATA:
          decodedLedgerEntryData.data = DataEntry.decode(stream);
          break;
        case CLAIMABLE_BALANCE:
          decodedLedgerEntryData.claimableBalance = ClaimableBalanceEntry.decode(stream);
          break;
        case LIQUIDITY_POOL:
          decodedLedgerEntryData.liquidityPool = LiquidityPoolEntry.decode(stream);
          break;
        case CONTRACT_DATA:
          decodedLedgerEntryData.contractData = ContractDataEntry.decode(stream);
          break;
        case CONTRACT_CODE:
          decodedLedgerEntryData.contractCode = ContractCodeEntry.decode(stream);
          break;
        case CONFIG_SETTING:
          decodedLedgerEntryData.configSetting = ConfigSettingEntry.decode(stream);
          break;
        case TTL:
          decodedLedgerEntryData.ttl = TTLEntry.decode(stream);
          break;
      }
      return decodedLedgerEntryData;
    }

    @Override
    public String toXdrBase64() throws IOException {
      return Base64Factory.getInstance().encodeToString(toXdrByteArray());
    }

    @Override
    public byte[] toXdrByteArray() throws IOException {
      ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
      XdrDataOutputStream xdrDataOutputStream = new XdrDataOutputStream(byteArrayOutputStream);
      encode(xdrDataOutputStream);
      return byteArrayOutputStream.toByteArray();
    }

    public static LedgerEntryData fromXdrBase64(String xdr) throws IOException {
      byte[] bytes = Base64Factory.getInstance().decode(xdr);
      return fromXdrByteArray(bytes);
    }

    public static LedgerEntryData fromXdrByteArray(byte[] xdr) throws IOException {
      ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(xdr);
      XdrDataInputStream xdrDataInputStream = new XdrDataInputStream(byteArrayInputStream);
      return decode(xdrDataInputStream);
    }
  }

  /**
   * LedgerEntryExt's original definition in the XDR file is:
   *
   * <pre>
   * union switch (int v)
   *     {
   *     case 0:
   *         void;
   *     case 1:
   *         LedgerEntryExtensionV1 v1;
   *     }
   * </pre>
   */
  @Data
  @NoArgsConstructor
  @AllArgsConstructor
  @Builder(toBuilder = true)
  public static class LedgerEntryExt implements XdrElement {
    private Integer discriminant;
    private LedgerEntryExtensionV1 v1;

    public static void encode(XdrDataOutputStream stream, LedgerEntryExt encodedLedgerEntryExt)
        throws IOException {
      // Xdrgen::AST::Typespecs::Int
      // Integer
      stream.writeInt(encodedLedgerEntryExt.getDiscriminant().intValue());
      switch (encodedLedgerEntryExt.getDiscriminant()) {
        case 0:
          break;
        case 1:
          LedgerEntryExtensionV1.encode(stream, encodedLedgerEntryExt.v1);
          break;
      }
    }

    public void encode(XdrDataOutputStream stream) throws IOException {
      encode(stream, this);
    }

    public static LedgerEntryExt decode(XdrDataInputStream stream) throws IOException {
      LedgerEntryExt decodedLedgerEntryExt = new LedgerEntryExt();
      Integer discriminant = stream.readInt();
      decodedLedgerEntryExt.setDiscriminant(discriminant);
      switch (decodedLedgerEntryExt.getDiscriminant()) {
        case 0:
          break;
        case 1:
          decodedLedgerEntryExt.v1 = LedgerEntryExtensionV1.decode(stream);
          break;
      }
      return decodedLedgerEntryExt;
    }

    @Override
    public String toXdrBase64() throws IOException {
      return Base64Factory.getInstance().encodeToString(toXdrByteArray());
    }

    @Override
    public byte[] toXdrByteArray() throws IOException {
      ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
      XdrDataOutputStream xdrDataOutputStream = new XdrDataOutputStream(byteArrayOutputStream);
      encode(xdrDataOutputStream);
      return byteArrayOutputStream.toByteArray();
    }

    public static LedgerEntryExt fromXdrBase64(String xdr) throws IOException {
      byte[] bytes = Base64Factory.getInstance().decode(xdr);
      return fromXdrByteArray(bytes);
    }

    public static LedgerEntryExt fromXdrByteArray(byte[] xdr) throws IOException {
      ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(xdr);
      XdrDataInputStream xdrDataInputStream = new XdrDataInputStream(byteArrayInputStream);
      return decode(xdrDataInputStream);
    }
  }
}
