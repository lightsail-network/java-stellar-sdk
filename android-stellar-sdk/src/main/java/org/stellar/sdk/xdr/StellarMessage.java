// Automatically generated by xdrgen 
// DO NOT EDIT or your changes may be overwritten

package org.stellar.sdk.xdr;


import java.io.IOException;

// === xdr source ============================================================

//  union StellarMessage switch (MessageType type)
//  {
//  case ERROR_MSG:
//      Error error;
//  case HELLO:
//      Hello hello;
//  case AUTH:
//      Auth auth;
//  case DONT_HAVE:
//      DontHave dontHave;
//  case GET_PEERS:
//      void;
//  case PEERS:
//      PeerAddress peers<>;
//  
//  case GET_TX_SET:
//      uint256 txSetHash;
//  case TX_SET:
//      TransactionSet txSet;
//  
//  case TRANSACTION:
//      TransactionEnvelope transaction;
//  
//  // SCP
//  case GET_SCP_QUORUMSET:
//      uint256 qSetHash;
//  case SCP_QUORUMSET:
//      SCPQuorumSet qSet;
//  case SCP_MESSAGE:
//      SCPEnvelope envelope;
//  case GET_SCP_STATE:
//      uint32 getSCPLedgerSeq; // ledger seq requested ; if 0, requests the latest
//  };

//  ===========================================================================
public class StellarMessage  {
  public StellarMessage () {}
  MessageType type;
  public MessageType getDiscriminant() {
    return this.type;
  }
  public void setDiscriminant(MessageType value) {
    this.type = value;
  }
  private Error error;
  public Error getError() {
    return this.error;
  }
  public void setError(Error value) {
    this.error = value;
  }
  private Hello hello;
  public Hello getHello() {
    return this.hello;
  }
  public void setHello(Hello value) {
    this.hello = value;
  }
  private Auth auth;
  public Auth getAuth() {
    return this.auth;
  }
  public void setAuth(Auth value) {
    this.auth = value;
  }
  private DontHave dontHave;
  public DontHave getDontHave() {
    return this.dontHave;
  }
  public void setDontHave(DontHave value) {
    this.dontHave = value;
  }
  private PeerAddress[] peers;
  public PeerAddress[] getPeers() {
    return this.peers;
  }
  public void setPeers(PeerAddress[] value) {
    this.peers = value;
  }
  private Uint256 txSetHash;
  public Uint256 getTxSetHash() {
    return this.txSetHash;
  }
  public void setTxSetHash(Uint256 value) {
    this.txSetHash = value;
  }
  private TransactionSet txSet;
  public TransactionSet getTxSet() {
    return this.txSet;
  }
  public void setTxSet(TransactionSet value) {
    this.txSet = value;
  }
  private TransactionEnvelope transaction;
  public TransactionEnvelope getTransaction() {
    return this.transaction;
  }
  public void setTransaction(TransactionEnvelope value) {
    this.transaction = value;
  }
  private Uint256 qSetHash;
  public Uint256 getQSetHash() {
    return this.qSetHash;
  }
  public void setQSetHash(Uint256 value) {
    this.qSetHash = value;
  }
  private SCPQuorumSet qSet;
  public SCPQuorumSet getQSet() {
    return this.qSet;
  }
  public void setQSet(SCPQuorumSet value) {
    this.qSet = value;
  }
  private SCPEnvelope envelope;
  public SCPEnvelope getEnvelope() {
    return this.envelope;
  }
  public void setEnvelope(SCPEnvelope value) {
    this.envelope = value;
  }
  private Uint32 getSCPLedgerSeq;
  public Uint32 getGetSCPLedgerSeq() {
    return this.getSCPLedgerSeq;
  }
  public void setGetSCPLedgerSeq(Uint32 value) {
    this.getSCPLedgerSeq = value;
  }
  public static void encode(XdrDataOutputStream stream, StellarMessage encodedStellarMessage) throws IOException {
  stream.writeInt(encodedStellarMessage.getDiscriminant().getValue());
  switch (encodedStellarMessage.getDiscriminant()) {
  case ERROR_MSG:
  Error.encode(stream, encodedStellarMessage.error);
  break;
  case HELLO:
  Hello.encode(stream, encodedStellarMessage.hello);
  break;
  case AUTH:
  Auth.encode(stream, encodedStellarMessage.auth);
  break;
  case DONT_HAVE:
  DontHave.encode(stream, encodedStellarMessage.dontHave);
  break;
  case GET_PEERS:
  break;
  case PEERS:
  int peerssize = encodedStellarMessage.getPeers().length;
  stream.writeInt(peerssize);
  for (int i = 0; i < peerssize; i++) {
    PeerAddress.encode(stream, encodedStellarMessage.peers[i]);
  }
  break;
  case GET_TX_SET:
  Uint256.encode(stream, encodedStellarMessage.txSetHash);
  break;
  case TX_SET:
  TransactionSet.encode(stream, encodedStellarMessage.txSet);
  break;
  case TRANSACTION:
  TransactionEnvelope.encode(stream, encodedStellarMessage.transaction);
  break;
  case GET_SCP_QUORUMSET:
  Uint256.encode(stream, encodedStellarMessage.qSetHash);
  break;
  case SCP_QUORUMSET:
  SCPQuorumSet.encode(stream, encodedStellarMessage.qSet);
  break;
  case SCP_MESSAGE:
  SCPEnvelope.encode(stream, encodedStellarMessage.envelope);
  break;
  case GET_SCP_STATE:
  Uint32.encode(stream, encodedStellarMessage.getSCPLedgerSeq);
  break;
  }
  }
  public static StellarMessage decode(XdrDataInputStream stream) throws IOException {
  StellarMessage decodedStellarMessage = new StellarMessage();
  MessageType discriminant = MessageType.decode(stream);
  decodedStellarMessage.setDiscriminant(discriminant);
  switch (decodedStellarMessage.getDiscriminant()) {
  case ERROR_MSG:
  decodedStellarMessage.error = Error.decode(stream);
  break;
  case HELLO:
  decodedStellarMessage.hello = Hello.decode(stream);
  break;
  case AUTH:
  decodedStellarMessage.auth = Auth.decode(stream);
  break;
  case DONT_HAVE:
  decodedStellarMessage.dontHave = DontHave.decode(stream);
  break;
  case GET_PEERS:
  break;
  case PEERS:
  int peerssize = stream.readInt();
  decodedStellarMessage.peers = new PeerAddress[peerssize];
  for (int i = 0; i < peerssize; i++) {
    decodedStellarMessage.peers[i] = PeerAddress.decode(stream);
  }
  break;
  case GET_TX_SET:
  decodedStellarMessage.txSetHash = Uint256.decode(stream);
  break;
  case TX_SET:
  decodedStellarMessage.txSet = TransactionSet.decode(stream);
  break;
  case TRANSACTION:
  decodedStellarMessage.transaction = TransactionEnvelope.decode(stream);
  break;
  case GET_SCP_QUORUMSET:
  decodedStellarMessage.qSetHash = Uint256.decode(stream);
  break;
  case SCP_QUORUMSET:
  decodedStellarMessage.qSet = SCPQuorumSet.decode(stream);
  break;
  case SCP_MESSAGE:
  decodedStellarMessage.envelope = SCPEnvelope.decode(stream);
  break;
  case GET_SCP_STATE:
  decodedStellarMessage.getSCPLedgerSeq = Uint32.decode(stream);
  break;
  }
    return decodedStellarMessage;
  }
}
