// Automatically generated by xdrgen 
// DO NOT EDIT or your changes may be overwritten

package org.stellar.sdk.xdr;


import java.io.IOException;

// === xdr source ============================================================

//  union Memo switch (MemoType type)
//  {
//  case MEMO_NONE:
//      void;
//  case MEMO_TEXT:
//      string text<28>;
//  case MEMO_ID:
//      uint64 id;
//  case MEMO_HASH:
//      Hash hash; // the hash of what to pull from the content server
//  case MEMO_RETURN:
//      Hash retHash; // the hash of the tx you are rejecting
//  };

//  ===========================================================================
public class Memo  {
  public Memo () {}
  MemoType type;
  public MemoType getDiscriminant() {
    return this.type;
  }
  public void setDiscriminant(MemoType value) {
    this.type = value;
  }
  private String text;
  public String getText() {
    return this.text;
  }
  public void setText(String value) {
    this.text = value;
  }
  private Uint64 id;
  public Uint64 getId() {
    return this.id;
  }
  public void setId(Uint64 value) {
    this.id = value;
  }
  private Hash hash;
  public Hash getHash() {
    return this.hash;
  }
  public void setHash(Hash value) {
    this.hash = value;
  }
  private Hash retHash;
  public Hash getRetHash() {
    return this.retHash;
  }
  public void setRetHash(Hash value) {
    this.retHash = value;
  }
  public static void encode(XdrDataOutputStream stream, Memo encodedMemo) throws IOException {
  stream.writeInt(encodedMemo.getDiscriminant().getValue());
  switch (encodedMemo.getDiscriminant()) {
  case MEMO_NONE:
  break;
  case MEMO_TEXT:
  stream.writeString(encodedMemo.text);
  break;
  case MEMO_ID:
  Uint64.encode(stream, encodedMemo.id);
  break;
  case MEMO_HASH:
  Hash.encode(stream, encodedMemo.hash);
  break;
  case MEMO_RETURN:
  Hash.encode(stream, encodedMemo.retHash);
  break;
  }
  }
  public static Memo decode(XdrDataInputStream stream) throws IOException {
  Memo decodedMemo = new Memo();
  MemoType discriminant = MemoType.decode(stream);
  decodedMemo.setDiscriminant(discriminant);
  switch (decodedMemo.getDiscriminant()) {
  case MEMO_NONE:
  break;
  case MEMO_TEXT:
  decodedMemo.text = stream.readString();
  break;
  case MEMO_ID:
  decodedMemo.id = Uint64.decode(stream);
  break;
  case MEMO_HASH:
  decodedMemo.hash = Hash.decode(stream);
  break;
  case MEMO_RETURN:
  decodedMemo.retHash = Hash.decode(stream);
  break;
  }
    return decodedMemo;
  }
}
